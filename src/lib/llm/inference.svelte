<script module lang="ts">

import { marked } from 'marked';


export let messages = $state([
    {
        "role": "user",
        "content": "Hello!"
    },
    {
        "role": "assistant",
        "content": "OK"
    }
]);
let buffer: Array<string> = $state([]);
let currentlyGenerating: boolean = $state(false);
let currentlyPrintingResponse: boolean = $state(false);
const markdownSpecialChars = new Set(['-', '#', '*', '>', '_', '=', '+', '`', '$']);


async function* generate() {
    const markdownTestData = [
    { 
        id: 1, 
        name: "# Titres et formatage de texte\n\n## Sous-titre h2\n\n### Sous-titre h3\n\nTexte normal avec **gras**, *italique*, et ***gras-italique***.\n\n~~Texte barr√©~~ et `code inline`.\n" 
    },
    { 
        id: 2, 
        name: "# Listes\n\n## Liste √† puces\n\n- Premier √©l√©ment\n- Deuxi√®me √©l√©ment\n  - Sous-√©l√©ment imbriqu√©\n  - Autre sous-√©l√©ment\n- Troisi√®me √©l√©ment\n\n## Liste num√©rot√©e\n\n1. Premier √©l√©ment\n2. Deuxi√®me √©l√©ment\n   1. Sous-√©l√©ment imbriqu√©\n   2. Autre sous-√©l√©ment\n3. Troisi√®me √©l√©ment\n" 
    },
    { 
        id: 3, 
        name: "# Citations et s√©parateurs\n\n> Ceci est une citation.\n> \n> Elle peut contenir plusieurs paragraphes.\n\nTexte normal apr√®s la citation.\n\n---\n\nTexte apr√®s un s√©parateur horizontal.\n" 
    },
    { 
        id: 4, 
        name: "# Liens et images\n\n[Lien vers Google](https://www.google.com)\n\n<https://example.com> - Lien automatique\n" 
    },
    { 
        id: 5, 
        name: "# Tableaux\n\n| En-t√™te 1 | En-t√™te 2 | En-t√™te 3 |\n| --------- | --------- | --------- |\n| Cellule 1 | Cellule 2 | Cellule 3 |\n| Ligne 2   | Donn√©es   | Autres    |\n| Ligne 3   | Texte     | Contenu   |\n" 
    },
    { 
        id: 6, 
        name: "# Blocs de code\n\n```javascript\nfunction hello() {\n  console.log('Bonjour le monde!');\n  return true;\n}\n\n// Un commentaire\nconst test = 123;\n```\n\n```css\nbody {\n  font-family: sans-serif;\n  color: #333;\n  margin: 0;\n  padding: 20px;\n}\n```\n" 
    },
    { 
        id: 7, 
        name: "# Listes de t√¢ches\n\n- [x] T√¢che termin√©e\n- [ ] T√¢che √† faire\n- [ ] Autre t√¢che √† faire\n  - [ ] Sous-t√¢che imbriqu√©e\n  - [x] Sous-t√¢che termin√©e\n" 
    },
    { 
        id: 8, 
        name: "# D√©tails d√©pliables\n\n<details>\n  <summary>Cliquez pour afficher plus d'informations</summary>\n  \n  Ce contenu est masqu√© par d√©faut et s'affiche quand on clique sur le titre.\n  \n  - Il peut contenir du Markdown\n  - Comme des listes\n  - Ou du **texte format√©**\n</details>\n" 
    },
    { 
        id: 9, 
        name: "# √âchappement de caract√®res sp√©ciaux\n\nSymboles √©chapp√©s: \\* \\_ \\~ \\` \\# \\[ \\] \\( \\) \\.\n\nEmojis: üëç üéâ üöÄ üí° ‚ö†Ô∏è\n" 
    },
    { 
        id: 10, 
        name: "# Combinaison d'√©l√©ments\n\n## Liste avec code\n\n- Item avec `code inline`\n- Item avec **texte en gras**\n\n## Tableau avec formatage\n\n| *Italique* | **Gras** | `Code` |\n| ---------- | -------- | ------ |\n| Contenu    | Contenu  | Contenu |\n\n> Citation contenant une liste:\n> - Premier point\n> - Second point\n> \n> Et du `code inline`.\n" 
    }
    ];
    await new Promise(resolve => setTimeout(resolve, 1000));
    for (const item of markdownTestData) {
        await new Promise(resolve => setTimeout(resolve, 50));
        yield item;
    }
}


async function fetch_response(prompt: string) {
    currentlyGenerating = true;
    for await (const item of generate()) {
        buffer.push(item.name);
    }
    currentlyGenerating = false;
}


async function print_buffer_content(): Promise<void> {
    messages.push({
        "role": "assistant",
        "content": ""
    });

    return new Promise(resolve => {
        let raw_message = "";    
        let inCodeBlock = false;
        let inMathBlock = false;

        let id = setInterval(async () => {
            if (buffer.length > 0) {
                let element = buffer[0];
                let letter = element[0];
                buffer[0] = element.slice(1);
                
                raw_message += letter;
                
                // Update special block flags
                if (letter === '`' && raw_message.endsWith('```')) {
                    inCodeBlock = !inCodeBlock;
                } else if (letter === '$' && raw_message.endsWith('$$')) {
                    inMathBlock = !inMathBlock;
                }
                const inSpecialContext = inCodeBlock || inMathBlock;
        
                if ((markdownSpecialChars.has(letter) && !inSpecialContext) || letter === " " || letter === "\n") {
                    // This is a weird situation, so let's wait until we parse again
                    messages[messages.length - 1].content += letter;
                } else {
                    messages[messages.length - 1].content = await marked(raw_message);
                }
                
                if (buffer[0].length === 0) {
                    buffer = buffer.slice(1);
                }
            } else {
                if (!currentlyGenerating) {
                    clearInterval(id);
                    // Final parse to make sure everything is correctly parsed
                    messages[messages.length - 1].content = await marked(raw_message);
                    resolve();
                }
            }
        }, 5);
    });
}

export async function prompt_llm(prompt: string) {
    currentlyPrintingResponse = true;
    messages.push({
        "role": "user",
        "content": prompt
    })
    fetch_response(prompt);
    await print_buffer_content();
    currentlyPrintingResponse = false;
}

export async function reset() {
    currentlyPrintingResponse = true;
    messages.splice(0, messages.length);
    buffer = ["Bonjour, je suis l'assistant de Nathan, promptez-moi !"];
    await print_buffer_content();
    currentlyPrintingResponse = false;
}

export function isCurrentlyGenerating(): boolean {
    return currentlyPrintingResponse;
}

</script>